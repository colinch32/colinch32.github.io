---
layout: post
title: Architecting Android...?
date: 2020-05-18 11:26
description: Over the last months and after having a few android discussions at Tuenti with colleagues like @pedro_g_s and  @flipper83, I have decided that was a good time to write an article about architecting android applications.
tags: [architecture]
comments: true
share: true
---


# Architecting Android...The clean way?

Over the last months and after having a few android discussions at  [Tuenti](http://corporate.tuenti.com/en/dev/blog)  with colleagues like  [@pedro_g_s](https://twitter.com/pedro_g_s)  and  [@flipper83](https://twitter.com/flipper83), I have decided that was a good time to write an article about  **architecting android applications.**

The purpose of it is to show you a  **little approach I had in mind**  in the last few months plus all the stuff I have learnt from investigating and implementing it.

## Getting Started

**We know that writing quality software is hard and complex:**  It is not only about satisfying requirements, also should be  **robust**,  **maintainable**,  **testable**  and  **flexible**  enough to adapt to growth and change. This is where “**the clean architecture**” comes up and could be a good approach for using when developing any software application.

The idea is simple: clean architecture stands for a group of practices that produce systems that are:

-   **Independent of Frameworks.**
-   **Testable.**
-   **Independent of UI.**
-   **Independent of Database.**
-   **Independent of any external agency.**

![clean_architecture_android](https://fernandocejas.com/assets/images/clean_architecture_clean_way_01.png)

It is not a must to use only 4 circles (as you can see in the picture), because they are only schematic but you should take into consideration the  **Dependency Rule:**  source code dependencies can only point inwards and nothing in an inner circle can know anything at all about something in an outer circle.

Here is some vocabulary that is relevant for getting familiar and understanding this approach in a better way:

-   **Entities:**  These are the business objects of the application.
-   **Use Cases:**  These use cases orchestrate the flow of data to and from the entities. Are also called Interactors.
-   **Interface Adapters:**  This set of adapters convert data from the format most convenient for the use cases and entities. Presenters and Controllers belong here.
-   **Frameworks and Drivers:**  This is where all the details go: UI, tools, frameworks, etc.

For a better and more extensive explanation, refer to  [this article](http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html)  or  [this video](https://vimeo.com/43612849).

## Our Scenario

**I will start with a simple scenario to get things going:**  simply create an small app that shows a list of friends or users retrieved from the cloud and, when clicking any of them, a new screen will be opened and for instance, show more details for that user.

Here is a quick video:

## Android Architecture

**The purpose is the separation of concerns by keeping the business rules not knowing anything at all about the outside world,**  thus, they can can be tested without any dependency to any external element.

To achieve this, my proposal is about breaking up the project into  **3 different layers**, in which each one has its own purpose and works separately from the others.

It is worth mentioning that  **each layer uses its own data model**  so this independence can be reached (you will see in code that a data mapper is needed in order to accomplish data transformation, a price to be paid if you do not want to cross the use of your models over the entire application).

Here is an schema so you can see how it looks like:

![clean_architecture_android](https://fernandocejas.com/assets/images/clean_architecture_clean_way_02.png)

**NOTE:**  I did not use any external library (except gson for parsing json data and junit, mockito, robolectric and espresso for testing). The reason is that it makes the example clearer. Anyway do not hesitate to add ORMs for storing disk data or any dependency injection framework or whatever tool or library you are familiar with, that could make your life easier.

**REMEMBER:**  reinventing the wheel is not a good practice.

## Presentation Layer

Is here, where the logic related with views and animations happens. It uses no more than a Model View Presenter ([MVP](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter)  from now on), but you can use any other pattern like MVC or MVVM. I will not get into details on it, but here  **fragments and activities are only views**, there is no logic inside them other than UI logic, and this is where all the rendering stuff takes place.

**Presenters in this layer are composed with interactors (use cases) that perform the job in a new thread outside the main android UI thread**, and come back using a callback with the data that will be rendered in the view.

![clean_architecture_android](https://fernandocejas.com/assets/images/clean_architecture_clean_way_03.png)

If you want a cool example about  [Effective Android UI](https://github.com/pedrovgs/EffectiveAndroidUI/)  that uses  **MVP**  and  **MVVM**, take a look at what my friend Pedro Gómez has done.

## Domain Layer

**Business rules here:**  all the logic happens in this layer. Regarding the android project, you will see all the interactors (use cases) implementations here as well.

**This layer is a pure java module**  without any android dependencies. All the external components use interfaces when connecting to the business objects.

![clean_architecture_android](https://fernandocejas.com/assets/images/clean_architecture_clean_way_04.png)

## Data Layer

All data needed for the application comes from this layer through a  **UserRepository**  implementation (the interface is in the domain layer) that uses a  [Repository Pattern](http://martinfowler.com/eaaCatalog/repository.html)  with a strategy that, through a factory, picks different data sources depending on certain conditions.

For instance, when getting a user by id, the disk cache data source will be selected if the user already exists in cache, otherwise the cloud will be queried to retrieve the data and later save it to the disk cache.

The idea behind all this is that  **the origin of the data is transparent to the client**, which does not care if the data is coming from memory, disk or the cloud, the only truth is that the information will arrive and will be gotten.

![clean_architecture_android](https://fernandocejas.com/assets/images/clean_architecture_clean_way_05.png)

**NOTE:**  In terms of code I have implemented a very simple and primitive disk cache using the file system and android preferences, it was for learning purpose. Remember again that you  **SHOULD NOT REINVENT THE WHEEL**  if there are existing libraries that perform these jobs in a better way.

## Error Handling

This is always a topic for discussion and could be great if you share your solutions here.

My strategy was to use callbacks, thus, if something happens in the data repository for example, the callback has 2 methods  `onResponse()`  and  `onError()`.

The last one encapsulates exceptions in a wrapper class called “**ErrorBundle**”: This approach brings some difficulties because there is a chains of callbacks one after the other until the error goes to the presentation layer to be rendered.  **Code readability could be a bit compromised.**

On the other side, I could have implemented an event bus system that throws events if something wrong happens, but this kind of solution is like using a  [GOTO](http://www.drdobbs.com/jvm/programming-with-reason-why-is-goto-bad/228200966), and, in my opinion, sometimes you can get lost when you’re subscribed to several events if you do not control them closely.

## Testing

Regarding testing, I opted for several solutions depending on the layer:

-   **Presentation Layer:**  used android instrumentation and espresso for integration and functional testing.
-   **Domain Layer:**  JUnit plus mockito for unit tests was used here.
-   **Data Layer:**  Robolectric (since this layer has android dependencies) plus junit plus mockito for integration and unit tests.

## Show me the code

I know that you may be wondering where is the code, right? Well  [here is the github link](https://github.com/android10/Android-CleanArchitecture)  where you will find what I have done.

About the folder structure, something to mention, is that the different layers are represented using modules:

-   **presentation:**  It is an android module that represents the presentation layer.
-   **domain:**  A java module without android dependencies.
-   **data:**  An android module from where all the data is retrieved.
-   **data-test:**  Tests for the data layer. Due to some limitations when using Robolectric I had to use it in a separate java module.

## Conclusion

As Uncle Bob says, “**Architecture is About Intent, not Frameworks**” and I totally agree with this statement. Of course there are a lot of different ways of doing things (different implementations) and I’m pretty sure that you (like me) face a lot of challenges every day, but by using this technique, you make sure that your application will be:

-   **Easy to maintain.**
-   **Easy to test.**
-   **Very cohesive.**
-   **Decoupled.**

As a conclusion I strongly recommend you give it a try and see and share your results and experiences, as well as any other approach you’ve found that works better:  **we do know that continuous improvement is always a very good and positive thing.**

I hope you have found this article useful and, as always, any feedback is more than welcome.

## Source code

-   [Clean architecture github repository – master branch](https://github.com/android10/Android-CleanArchitecture)
-   [Clean architecture github repository – releases](https://github.com/android10/Android-CleanArchitecture/releases)

## Further reading:

-   [Architecting Android..reloaded](https://fernandocejas.com/2018/05/07/architecting-android-reloaded/)
-   [Architecting Android..the evolution](https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/)
-   [Tasting Dagger 2 on Android](https://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/)
-   [The Mayans Lost Guide to RxJava on Android](https://speakerdeck.com/android10/the-mayans-lost-guide-to-rxjava-on-android)
-   [It is about philosophy: Culture of a good programmer](https://speakerdeck.com/android10/it-is-about-philosophy-culture-of-a-good-programmer)

## Links and Resources

-   [The clean architecture by Uncle Bob](http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html)
-   [Architecture is about Intent, not Frameworks](http://www.infoq.com/news/2013/07/architecture_intent_frameworks)
-   [Model View Presenter](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter)
-   [Repository Pattern by Martin Fowler](http://martinfowler.com/eaaCatalog/repository.html)
-   [Android Design Patterns Presentation](http://www.slideshare.net/PedroVicenteGmezSnch/)

# Architecting Android...The evolution

Hey there! After a while (and a lot of feedback received) I decided it was a good time to get back to this topic and give you another taste of what I consider a good approach when it comes to  **architecting modern mobile applications**  (android in this case).

Before getting started, I assume that  [you already read my previous post about Architecting Android…The clean way?](https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/). If not, this is a good opportunity to get in touch with it in order to have a better understanding of the story I’m going to tell you right here:

![clean_architecture](https://fernandocejas.com/assets/images/clean_architecture_evolution_01.png)

## Architecture evolution

**Evolution stands for a gradual process in which something changes into a different and usually more complex or better form.**

Said that, software evolves and changes over the time and indeed an architecture. Actually  **a good software design must help us grow and extend our solution by keeping it healthy without having to rewrite everything**  (although there are cases where this approach is better, but that is a topic for another article, so let’s focus in what I pointed out earlier, trust me).

In this article, I am going to walk you through key points I consider necessary and important, to keep the sanity of our android codebase.

Keep in mind this picture and let’s get started.

![clean_architecture](https://fernandocejas.com/assets/images/clean_architecture_evolution_02.png)

## Reactive approach: RxJava

I’m not going to talk about the benefits of RxJava here ([I assume you already had a taste of it](https://github.com/ReactiveX/RxJava/wiki/)), since  [there are a lot articles](http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/)  and  [badasses](https://speakerdeck.com/benjchristensen)  of this technology that are doing an excellent job out there.

**However, I will point out what makes it interesting in regards of android applications development, and how it has helped me evolve my first approach of clean architecture.**

First, I opted for a reactive pattern by converting use cases (called interactors in the clean architecture naming convention) to return  `Observables<T>`  which means all the lower layers will follow the chain and return  `Observables<T>`  too.

```
public abstract class UseCase {

  private final ThreadExecutor threadExecutor;
  private final PostExecutionThread postExecutionThread;

  private Subscription subscription = Subscriptions.empty();

  protected UseCase(ThreadExecutor threadExecutor,
      PostExecutionThread postExecutionThread) {
    this.threadExecutor = threadExecutor;
    this.postExecutionThread = postExecutionThread;
  }

  protected abstract Observable buildUseCaseObservable();

  public void execute(Subscriber UseCaseSubscriber) {
    this.subscription = this.buildUseCaseObservable()
        .subscribeOn(Schedulers.from(threadExecutor))
        .observeOn(postExecutionThread.getScheduler())
        .subscribe(UseCaseSubscriber);
  }

  public void unsubscribe() {
    if (!subscription.isUnsubscribed()) {
      subscription.unsubscribe();
    }
  }
}

```

As you can see here, all use cases inherit from this abstract class and implement the abstract method  `buildUseCaseObservable()`  which will setup an  `Observable<T>`  that is going to  **do the hard job and return the needed data.**

Something to highlight is the fact that on  `execute()`  method, we make sure our  `Observable<T>`  executes itself in a separate thread, thus, minimizing how much we block the android main thread.  **The result is push back on the Android main thread through the android main thread scheduler.**

So far, we have our  `Observable<T>`  up and running, but, as you know, someone has to observe the data sequence emitted by it.

To achieve this, I evolved  **Presenters**  (part of MVP in the presentation layer) into  **Subscribers**  which would “react” to these emitted items by use cases in order to update the user interface.

Here is how the Subscriber looks like:

```
private final class UserListSubscriber extends DefaultSubscriber<List<User>> {

  @Override public void onCompleted() {
    UserListPresenter.this.hideViewLoading();
  }

  @Override public void onError(Throwable e) {
    UserListPresenter.this.hideViewLoading();
    UserListPresenter.this.showErrorMessage(new DefaultErrorBundle((Exception) e));
    UserListPresenter.this.showViewRetry();
  }

  @Override public void onNext(List<User> users) {
    UserListPresenter.this.showUsersCollectionInView(users);
  }
}

```

**Every subscriber is an inner class inside each presenter**  and implements a  `DefaultSubscriber<T>`  created basically for default error handling.

After putting all pieces in place, you can get the whole idea by having a look at the following picture:

![clean_architecture](https://fernandocejas.com/assets/images/clean_architecture_evolution_03.png)

Let’s enumerate a bunch of  **benefits**  we get out of this  **RxJava**  based approach:

-   **Decoupling between Observables and Subscribers:**  makes maintainability and testing easier.
-   **Simplified asynchronous tasks:**  java threads and futures are complex to manipulate and synchronize if more than one single level of asynchronous execution is required, so by using schedulers we can jump between background and main thread in an easy way (with no extra effort), especially when we need to update the UI. We also avoid what we call a “callback hell”, which makes our code unreadable and hard to follow up.
-   **Data transformation/composition:**  we can combine multiple  `Observables<T>`  without affecting the client, which makes our solution more scalable.
-   **Error handling:**  a signal is emitted to the consumer when an error has occurred within any  `Observable<T>`.

From my point of view there is  **one drawback**, and indeed a price to pay, which has to do with the  **learning curve**  for developers who are not familiar with the concept. However, you get very valuable stuff out of it. Reactive for the win!

## Dependency Injection: Dagger 2

I’m not going to talk much of dependency injection cause  [I have already written a whole article](https://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/), which I strongly recommend you to read, so we can stay on the same page here.

With that being said, it is worth mentioning, that by implementing a dependency injection framework like Dagger 2 we gain:

-   **Components reuse**, since dependencies can be injected and configured externally.
-   When  **injecting abstractions as collaborators**, we can just change the implementation of any object without having to make a lot of changes in our codebase, since that object instantiation resides in one place isolated and decoupled.
-   Dependencies can be injected into a component:  **it is possible to inject mock implementations of these dependencies which makes testing easier.**

## Lambda expressions: Retrolambda

No one will complain about making use of Java 8 lambdas in our code, and even more when they  **simplify it**  and  **get rid of a lot of boilerplate**, as you can see in this piece of code:

```
private final Action1<UserEntity> saveToCacheAction =
    userEntity -> {
      if (userEntity != null) {
        CloudUserDataStore.this.userCache.put(userEntity);
      }
    };

```

However, I have mixed feelings here and will explain why. It turns out that at  [@SoundCloud](https://developers.soundcloud.com/blog/)  we had a discussion around  [Retrolambda](https://github.com/orfjackal/retrolambda), mainly whether or not to use it, and the outcome was:

-   Pros:
    -   **Lambdas and method references.**
    -   **Try with resources.**
    -   **Dev karma.**
-   Cons:
    -   **Accidental use of Java 8 APIs.**
    -   **3rd part lib, quite intrusive.**
    -   **3rd part gradle plugin to make it work with Android.**

Finally we decided it was not something that would solve any problems for us: your code looks better and more readable but it was something we could live without, since nowadays all the most powerful IDEs contain code folding options which cover this need, at least in an acceptable manner.

Honestly, the main reason why I used it here, was more to play around it and have a taste of lambdas on Android, although I would probably use it again for a spare time project. **I will leave the decision up to you**. I am just exposing my field of vision here. Of course the  [author](https://github.com/orfjackal)  of this library deserves my  **kudos for such an amazing job.**

## Testing approach

In terms of testing, not big changes in relation with the first version of the example:

-   **Presentation layer:**  UI tests with Espresso 2 and Android Instrumentation.
-   **Domain layer:**  JUnit + Mockito since it is a regular Java module.
-   **Data layer:**  Migrated test battery to use Robolectric 3 + JUnit + Mockito. Tests for this layer used to live in a separate Android Module, since back then (at the moment of the first version of the example), there was no built-in unit test support and setting up a framework like robolectric was complicated and required a serie of hacks to make it work properly. Fortunately that is part of the past and now everything works out of the box so I could relocated them inside the data module, specifically into its default test location:  `src/test/java`  folder.

## Package organization

I consider code/package organization one of the key factors of a good architecture:  **package structure is the very first thing encountered by a programmer when browsing source code.**  Everything flows from it. Everything depends on it.

We can distinguish between 2 paths you can take to divide up your application into packages:

-   **Package by layer:**  Each package contains items that usually are not closely related to each other. This results in packages with low cohesion and low modularity, with high coupling between packages. As a result, editing a feature involves editing files across different packages. In addition, deleting a feature can almost never be performed in a single operation.
-   **Package by feature:**  It uses packages to reflect the feature set. It tries to place all items related to a single feature (and only that feature) into a single package. This results in packages with high cohesion and high modularity, and with minimal coupling between packages. Items that work closely together are placed next to each other. They are not spread out all over the application.

My recommendation is to go with packages by features, which bring these main benefits:

-   **Higher Modularity**
-   **Easier Code Navigation**
-   **Minimizes Scope**

It is also interesting to add that if you are working with  **feature teams**  (as we do at  [@SoundCloud](https://twitter.com/soundcloud)), code ownership will be easier to organize and more modularized, which is a win in a growing organization where many developers work on the same codebase.

![package_organization](https://fernandocejas.com/assets/images/clean_architecture_evolution_04.png)

As you can see, my approach looks like packages organized by layer: I might have gotten wrong here (and group everything under ‘users’ for example) but  **I will forgive myself in this case,**  because this sample is for learning purpose and what I wanted to expose, were the main concepts of the clean architecture approach.  **DO AS I SAY, NOT AS I DO**  :).

## Extra ball: organizing your build logic

**We all know that you build a house from the foundations up**. The same happens with software development, and here I want to remark that, from my perspective, the build system (and its organization) is an important piece of a software architecture.

On Android, we use gradle, which is a platform agnostic build system and indeed, very powerful.

The idea here is to go through a bunch of tips and tricks that can  **simplify your life**  when it comes to how organize the way you build your application:

-   **Group stuff by functionality in separate gradle build files.**

![gradle_organization](https://fernandocejas.com/assets/images/clean_architecture_evolution_05.png)

```
def ciServer = 'TRAVIS'
def executingOnCI = "true".equals(System.getenv(ciServer))

// Since for CI we always do full clean builds, we don't want to pre-dex
// See http://tools.android.com/tech-docs/new-build-system/tips
subprojects {
  project.plugins.whenPluginAdded { plugin ->
    if ('com.android.build.gradle.AppPlugin'.equals(plugin.class.name) ||
        'com.android.build.gradle.LibraryPlugin'.equals(plugin.class.name)) {
      project.android.dexOptions.preDexLibraries = !executingOnCI
    }
  }
}

```

```
apply from: 'buildsystem/ci.gradle'
apply from: 'buildsystem/dependencies.gradle'

buildscript {
  repositories {
    jcenter()
  }
  dependencies {
    classpath 'com.android.tools.build:gradle:1.2.3'
    classpath 'com.neenbedankt.gradle.plugins:android-apt:1.4'
  }
}

allprojects {
  ext {
	...
  }
}
...

```

Thus, you can use apply from:  `buildsystem/ci.gradle`  to plug that configuration to any gradle build file. Do not put everything on only one  `build.gradle`  file otherwise you will start creating a monster. Lesson learned.

-   **Create maps of dependencies.**

```
...

ext {
  //Libraries
  daggerVersion = '2.0'
  butterKnifeVersion = '7.0.1'
  recyclerViewVersion = '21.0.3'
  rxJavaVersion = '1.0.12'

  //Testing
  robolectricVersion = '3.0'
  jUnitVersion = '4.12'
  assertJVersion = '1.7.1'
  mockitoVersion = '1.9.5'
  dexmakerVersion = '1.0'
  espressoVersion = '2.0'
  testingSupportLibVersion = '0.1'
  
  ...
  
  domainDependencies = [
      daggerCompiler:     "com.google.dagger:dagger-compiler:${daggerVersion}",
      dagger:             "com.google.dagger:dagger:${daggerVersion}",
      javaxAnnotation:    "org.glassfish:javax.annotation:${javaxAnnotationVersion}",
      rxJava:             "io.reactivex:rxjava:${rxJavaVersion}",
  ]

  domainTestDependencies = [
      junit:              "junit:junit:${jUnitVersion}",
      mockito:            "org.mockito:mockito-core:${mockitoVersion}",
  ]

  ...

  dataTestDependencies = [
      junit:              "junit:junit:${jUnitVersion}",
      assertj:            "org.assertj:assertj-core:${assertJVersion}",
      mockito:            "org.mockito:mockito-core:${mockitoVersion}",
      robolectric:        "org.robolectric:robolectric:${robolectricVersion}",
  ]
}

```

```
apply plugin: 'java'

sourceCompatibility = 1.7
targetCompatibility = 1.7

...

dependencies {
  def domainDependencies = rootProject.ext.domainDependencies
  def domainTestDependencies = rootProject.ext.domainTestDependencies

  provided domainDependencies.daggerCompiler
  provided domainDependencies.javaxAnnotation

  compile domainDependencies.dagger
  compile domainDependencies.rxJava

  testCompile domainTestDependencies.junit
  testCompile domainTestDependencies.mockito
}

```

**This is very useful if you want to reuse the same artifact version across different modules in your project**, or maybe the other way around, where you have to apply different dependency versions to different modules.

Another plus one, is that you also control the dependencies in one place and, for instance,  **bumping an artifact version is pretty straightforward.**

## Wrapping up

That is pretty much I have for now, and as a conclusion, keep in mind there are  **no silver bullets**. However, a good software architecture will help us keep our  **code clean and healthy**, as well as scalable and easy to maintain.

There is a few more things I would like to point out and they have to do with attitudes you should take when facing a software problem:

-   **Respect SOLID principles.**
-   **Do not over think (do not do over engineering).**
-   **Be pragmatic.**
-   **Minimize framework (android) dependencies in your project as much as you can.**

## Source code

-   [Clean architecture github repository - master branch](https://github.com/android10/Android-CleanArchitecture)
-   [Clean architecture github repository - releases](https://github.com/android10/Android-CleanArchitecture/releases)

## Further reading:

-   [Architecting Android..reloaded](https://fernandocejas.com/2018/05/07/architecting-android-reloaded/)
-   [Architecting Android..the clean way](https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/)
-   [Tasting Dagger 2 on Android](https://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/)
-   [The Mayans Lost Guide to RxJava on Android](https://speakerdeck.com/android10/the-mayans-lost-guide-to-rxjava-on-android)
-   [It is about philosophy: Culture of a good programmer](https://speakerdeck.com/android10/it-is-about-philosophy-culture-of-a-good-programmer)

## References

-   [RxJava wiki by Netflix](https://github.com/ReactiveX/RxJava/wiki)
-   [Framework bound by Uncle Bob](https://blog.8thlight.com/uncle-bob/2014/05/11/FrameworkBound.html)
-   [Gradle user guide](https://docs.gradle.org/current/userguide/userguide.html)
-   [Package by feature, not layer](http://www.javapractices.com/topic/TopicAction.do?Id=205)

# Architecting Android...Reloaded

After a long time I decided to write again about  **Architecture on Android Applications**. The reason? Mainly  **feedaback**  from the community and  **lessons learned**. But even though a lot has been said since the early days when  **Clean Architecture**  became popular in Mobile Development, there is always room for improvement and evolution.

 **Clean Architecture**가 모바일 개발에서 대중화 된 초기부터 많은 이야기가 있었지만 항상 개선과 진화의 여지가 있습니다.

In order to get started and get things easier, I will assume you have already read these old but still valid blog posts:

-   [Architecting Android…The clean way?](https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/)
-   [Architecting Android…The evolution.](https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/)

Based on the above articles clean architecture example, there is a clear evolution in the codebase, especially because nowadays with applications being key at a business level, more than ever, there is a need to  **scale**,  **modularize**  and  **organize teams**  around Mobile Development (mainly due to its complexity).

Thus, the idea is to come up with an (elegant?) solution which will make our life easier in terms of:

-   **Problem solving.**
-   **Scalability.**
-   **Modularization.**
-   **Testability.**
-   **Independence of frameworks, UI and Databases.**

![clean_architecture](https://fernandocejas.com/assets/images/clean_architecture_reloaded_main.png)

This is the big picture, which should look familiar if you have been using  **Clean Architecture**  in your Android Applications.

## Our scenario

A simple Movies Android Application (any similarities with reality is a mere coincidence).

Written in  **Kotlin**: not much to say other than that we want to leverage a modern language’s features like  **inmutability, conciseness, functional programming,**  etc.

With the following flow:

![clean_architecture](https://fernandocejas.com/assets/images/clean_architecture_reloaded_screenshots.png)

Where we have 3 main use cases:

-   Get a list of movies.
-   Show details for an specific clicked movie.
-   Play a movie.

As usual, the  [source code is available on github.](https://github.com/android10/Android-CleanArchitecture-Kotlin)

## General Architecture

The general principle is to use a basic  **3 tiers architecture**. The good thing about it, is that it is very easy to understand and many people are familir with it. So we will break down our solution into layers in order to respect the dependency rule (where dependencies flow in one direction: check above the rounded clean architecture graph):

![clean_architecture](https://fernandocejas.com/assets/images/clean_architecture_reloaded_layers.png)

Nothing new here if we keep in mind my  [previous posts,](https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/)  but do not stop reading yet. Let’s dive deeper and go piece by piece for a better understanding.

## Domain Layer: Functional Use Cases

A use case is an intention, in other words, something we want to do in our application, one of our main players.  **And its main responsibility is to orchestrate our domain logic and its connection with both UI and Data layers.**

By using the power of Kotlin and its treatment of functions as first class citizens (more coming up shortly), we have in our framework a  [UseCase](https://github.com/android10/Android-CleanArchitecture-Kotlin/blob/master/app/src/main/kotlin/com/fernandocejas/sample/core/interactor/UseCase.kt)  abstraction, which acts as a contract for all the use cases in our application.

```
abstract class UseCase<out Type, in Params> where Type : Any {

    abstract suspend fun run(params: Params): Either<Failure, Type>

    fun execute(onResult: (Either<Failure, Type>) -> Unit, params: Params) {
        val job = async(CommonPool) { run(params) }
        launch(UI) { onResult.invoke(job.await()) }
    }
}

```

### What is going on here?

We have an  [abstract class](https://github.com/android10/Android-CleanArchitecture-Kotlin/blob/master/app/src/main/kotlin/com/fernandocejas/sample/core/interactor/UseCase.kt)  which takes 2 generic parameters:

-   `<out Type>`: a return type which is the result of the executed use case.
-   `<in Params>`: a parameters class which will be consumed inside the run() function in case we need extra data for our use case.

The  **execute()**  function is where all the magic happens:

-   We pass a “**onResult**” function as a parameter which takes an  **Either<Failure, Type>**  and returns  **Unit**  (in the Error Handling section I will extend the explanation for  **Either<L, R>**, so be patient please :)). The good thing is that the caller of the UseCase is actually establishing the desired behaviour by passing this inmutable function (onResult), thus, avoiding any internal exposure or side effects if we were passing objects (one of the benefits of FP, more coming up).
-   Also, by using  **Kotlin coroutines**  we invoke the passed “onResult” function in a  **different thread,**  so from this point on, we are safe to write our code in a synchronous fashion. The result will be posted on the  **Android Main UI Thread.**

`abstract suspend fun run(params: Params)`  is what we have to override when extending the  [UseCase<out Type, in Params>](https://github.com/android10/Android-CleanArchitecture-Kotlin/blob/master/app/src/main/kotlin/com/fernandocejas/sample/core/interactor/UseCase.kt)  abstraction, so for instance, this is how our  [GetMovies](https://github.com/android10/Android-CleanArchitecture-Kotlin/blob/master/app/src/main/kotlin/com/fernandocejas/sample/features/movies/GetMovies.kt)  use case looks like:

```
class GetMovies 
@Inject constructor(private val moviesRepository: MoviesRepository) : 
    UseCase<List<Movie>, None>() {

    override suspend fun run(params: None) = moviesRepository.movies()
}

```

In this example we are delegating movies retrieval to a  **Repository.**  Easy right?

## UI Layer: From MVP to MVVM

The  **Model-View-ViewModel**  Pattern (MVVM) provides a clean separation of concerns between user interface and domain logic.

It has 3 main components: the  **model**, the  **view**, and the  **view model**. There are relationships between them, although each serves a distinct and separate role:

![clean_architecture](https://fernandocejas.com/assets/images/clean_architecture_reloaded_mvvm.png)

At the highest level, the view “knows about” the view model, and the view model “knows about” the model, but the model is unaware of the view model, and the view model is unaware of the view.  **The view model isolates the view from the model classes and allows the model to evolve independently of the view.**

At implementation level, in our example,  **MVVM**  is accomplished by the usage of  [Architecture Components](https://developer.android.com/topic/libraries/architecture/), which its main advantage is to handle configuration changes when the screen rotates, something that has given us many headaches as android developers (I guess you know what I’m talking about).

**_Disclaimer:_**  that does not mean we have to no longer care about lifecycles, but it is way easier.

A comment on MVP (Model View Presenter) from  [previous example:](https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/)  I found tricky to avoid leaks due to activities and fragments being recreated so I used a  **poor man solution: retain fragments.**

However, I ran into these sort of situations anyway. This is the reason why I decided to go and give a try to MVVM.

### Let’s see what changed with MVVM from previous sample and how it works:

![clean_architecture](https://fernandocejas.com/assets/images/clean_architecture_reloaded_mvvm_app.png)

-   **Fragments act as views**, where all the logic related to displaying data on the screen happens.
-   **Fragments also know about ViewModels**, they actually subscribe to ViewModels.
-   **ViewModels contain LiveData**  objects and references to UseCases.
-   **UseCases update LiveData**  which react to those changes and send notifications to ViewModels.
-   **ViewModels talk to subscribed Fragments**  in order to update the UI.

In order to see all these pieces working together, let’s see some code.

**ViewModel**  containing  **LiveData**  and updating by calling  **UseCase.execute()**  function:

```
class MoviesViewModel
@Inject constructor(private val getMovies: GetMovies) : BaseViewModel() {

    var movies: MutableLiveData<List<MovieView>> = MutableLiveData()

    fun loadMovies() = 
        getMovies.execute({ it.either(::handleFailure, ::handleMovieList) }, None())

    private fun handleMovieList(movies: List<Movie>) {
        this.movies.value = movies.map { MovieView(it.id, it.poster) }
    }
}

```

**Fragment**  subscribing to the above  **ViewModel**  on  **onCreate()**.

I used a  [couple of tricks](https://github.com/android10/Android-CleanArchitecture-Kotlin/blob/master/app/src/main/kotlin/com/fernandocejas/sample/core/extension/Fragment.kt#L33)  with extension functions to get rid of some verbosity and boilerplate.

```
class MoviesFragment : BaseFragment() {

    @Inject lateinit var navigator: Navigator
    @Inject lateinit var moviesAdapter: MoviesAdapter

    private lateinit var moviesViewModel: MoviesViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        appComponent.inject(this)

        //subscribtion to LiveData in MoviesViewModel
        moviesViewModel = viewModel(viewModelFactory) {
            observe(movies, ::renderMoviesList)
            failure(failure, ::handleFailure)
        }
    }
	...
}

```

## Data Layer: Repository Pattern to the rescue

Anything new here in comparison with the  [previous example](https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/)  since I have had really good results with it.

To keep in mind:  **At its core the Repository pattern is a simple interface.**  It exists as a layer between our domain and our data so that our logic doesn’t need to be concerned with the implementation of different data sources: Network, Database or Memory.

![clean_architecture](https://fernandocejas.com/assets/images/clean_architecture_reloaded_repository.png)

In the following chunk of code we can see our  [MoviesRepositoy](https://github.com/android10/Android-CleanArchitecture-Kotlin/blob/master/app/src/main/kotlin/com/fernandocejas/sample/features/movies/MoviesRepository.kt)  contract:

```
interface MoviesRepository {
    fun movies(): Either<Failure, List<Movie>>
    fun movieDetails(movieId: Int): Either<Failure, MovieDetails>
}

```

[In our example](https://github.com/android10/Android-CleanArchitecture-Kotlin/blob/master/app/src/main/kotlin/com/fernandocejas/sample/features/movies/GetMovies.kt#L23)  we usually inject a  [Repositoy](https://github.com/android10/Android-CleanArchitecture-Kotlin/blob/master/app/src/main/kotlin/com/fernandocejas/sample/features/movies/MoviesRepository.kt)  as a collaborator for our  **UseCases**  implementations.

## Functional Error Handling

Overall  **Error/Exception Handling**  should be taken care at design and not at implementention level, and in my opinion, one of the biggest mistakes we make as developers (lesson learned). That is why it is important to have a framework in place for this purpose.

### What happens with traditional Error Handling?

Observing exceptions (try/catch blocks) and making decisions based on it that changes the control flow is a bad practice: it creates unprediction, affects our resilience and debugging becomes difficult, especially in concurrent environments. Plus going back to C-style error handling, using error codes which need to be checked by convention could be a nightmare.

With that being said, we have seen we are using  **Either<L, R>**  as a return type in our  [UseCase](https://github.com/android10/Android-CleanArchitecture-Kotlin/blob/master/app/src/main/kotlin/com/fernandocejas/sample/core/interactor/UseCase.kt)  abstraction:

```
abstract suspend fun run(params: Params): Either<Failure, Type>

```

### So let me introduce Either

**Either<L, R>**  is referred as a disjoint function, which means that this structure is designed to hold either a  **Left<T>**  or  **Right<T>**  value but never both. It is a  **funcional programming monadic type**  not yet existent in the Kotlin Standard Library.

Here is a simple implementation which perfectly fulfills my needs and it is easy to understand and use (ideas taken from  [Alex Hart](https://proandroiddev.com/kotlins-nothing-type-946de7d464fb)):

```
/**
 * Represents a value of one of two possible types (a disjoint union).
 * Instances of [Either] are either an instance of [Left] or [Right].
 * FP Convention dictates that: 
 *      [Left] is used for "failure".
 *      [Right] is used for "success".
 *
 * @see Left
 * @see Right
 */
sealed class Either<out L, out R> {
    /** * Represents the left side of [Either] class which by convention is a "Failure". */
    data class Left<out L>(val a: L) : Either<L, Nothing>()
    /** * Represents the right side of [Either] class which by convention is a "Success". */
    data class Right<out R>(val b: R) : Either<Nothing, R>()

    val isRight get() = this is Right<R>

    val isLeft get() = this is Left<L>

    fun either(fnL: (L) -> Any, fnR: (R) -> Any): Any =
            when (this) {
                is Either.Left -> fnL(a)
                is Either.Right -> fnR(b)
            }

    fun <T> flatMap(fn: (R) -> Either<L, T>): Either<L, T> {...}
    fun <T> map(fn: (R) -> (T)): Either<L, T> {...}
}

```

Let me also quote  [Daniel Westheide](https://danielwestheide.com/)  (a Scala guru and good person, whom I bumped into at SoundCloud) in one of his amazing blog posts:

> There is nothing in the semantics of the  **Either<L, R>**  type that specifies one or the other sub type to represent an error or a success, respectively. In fact,  **Either**  is a general-purpose type for use whenever you need to deal with situations where the result can be of one of two possible types.

> Nevertheless, error handling is a popular use case for it, and by convention, when using it that way, the  **Left<T>**  represents the error case, whereas the  **Right<T>**  contains the success value.

And please do not forget to read his entire serie of scala posts to expand your horizons even more (getting ideas from other languages is always a +1):

-   [Error Handling With Try.](http://danielwestheide.com/blog/2012/12/26/the-neophytes-guide-to-scala-part-6-error-handling-with-try.html)
-   [The Either Type.](http://danielwestheide.com/blog/2013/01/02/the-neophytes-guide-to-scala-part-7-the-either-type.html)

### What about our code sample then?

In the  [GetMovies](https://github.com/android10/Android-CleanArchitecture-Kotlin/blob/master/app/src/main/kotlin/com/fernandocejas/sample/features/movies/GetMovies.kt)  use case, at implementation level, we always return an  **Either<Failure, List<Movie>>**  up starting from the data layer, all the way up to our  **MoviesViewModel**  which updates “either” the failure  **LiveData<Failure>**  (in case of failure, Left<T>) or the movies  **LiveData<List<MovieView>>**(success, Right<T>):

```
class MoviesViewModel
@Inject constructor(private val getMovies: GetMovies) {

    var movies: MutableLiveData<List<MovieView>> = MutableLiveData()
    var failure: MutableLiveData<Failure> = MutableLiveData()

    fun loadMovies() = 
        getMovies.execute({ it.either(::handleFailure, ::handleMovieList) }, None())

    private fun handleMovieList(movies: List<Movie>) {
        this.movies.value = movies.map { MovieView(it.id, it.poster) }
    }

    private fun handleFailure(failure: Failure) {
        this.failure.value = failure
    }
}

```

At a View level (our  [MoviesFragment](https://github.com/android10/Android-CleanArchitecture-Kotlin/blob/master/app/src/main/kotlin/com/fernandocejas/sample/features/movies/MoviesFragment.kt)), we subscribe to the updates coming from the view model:

```
moviesViewModel = viewModel(viewModelFactory) {
    observe(movies, ::renderMoviesList)
    failure(failure, ::handleFailure)
} 

```

And this is how  **handleFailure()**  looks like for  [Failure](https://github.com/android10/Android-CleanArchitecture-Kotlin/blob/master/app/src/main/kotlin/com/fernandocejas/sample/core/exception/Failure.kt)  treatment:

```
private fun handleFailure(failure: Failure?) {
    when (failure) {
        is NetworkConnection -> renderFailure(R.string.failure_network_connection)
        is ServerError -> renderFailure(R.string.failure_server_error)
        is ListNotAvailable -> renderFailure(R.string.failure_movies_list_unavailable)
    }
}

```

By the way,  [Failure](https://github.com/android10/Android-CleanArchitecture-Kotlin/blob/master/app/src/main/kotlin/com/fernandocejas/sample/core/exception/Failure.kt)  is a sealed class which offers global default Failures:

```
/**
 * Base Class for handling errors/failures/exceptions.
 * Every feature specific failure should extend [FeatureFailure] class.
 */
sealed class Failure {
    class NetworkConnection: Failure()
    class ServerError: Failure()

    /** * Extend this class for feature specific failures.*/
    abstract class FeatureFailure: Failure()
}

```

I hope now the usage of  **Either<L, R>**  is clearer and you understand the reason and benefits of this applied technique.

## First steps to Modularization

First, in my defense, this post is NOT about this specific topic (which by the way, is huge) but I want to write down some hints based in past experiences, in order to get started. From my perspective, sooner or later, this is the way to go, and  **a good architecture should help out to achieve this goal.**

### What is Modularization?

**Modularization is the process of separating and creating clear boundaries between logical components of code.**

[If you did your homework and checked my previous posts about clean architecture](https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/), you might have seen that I used android modules for representing each layer involved in the architecture.

A recurring question in discussions was: Why? The answer is simple… Wrong technical decision: I relied on different modules in order to be more strict with the dependency rule by establishing borders and, thus, make it more difficult to break it.

**But power comes with big responsibilities,**  and even though this worked pretty well in the beginning, the sample was still a  **MONOLITH**  and it would bring problems when scaling up:

-   when modifying or adding a new functionality: we had to touch every single module/layer (strong dependencies/coupling between modules).
-   conflicts when developers working in the codebase (the bigger the team, the more conflicts, especially with PRs and git).

### Embrace Application Modularization

My first tip to favor modularization is to organize packages by features, this way we accomplish:

-   **Higher Modularity.**
-   **High Cohesion.**
-   **Easier Code Navigation.**
-   **Minimizes Scope.**
-   **Isolation and Encapsulation.**

**Code/package organization**  is one of the key factors of a good architecture: package structure is the very first thing encountered by a programmer when browsing source code. Everything flows from it. Everything depends on it.

![clean_architecture](https://fernandocejas.com/assets/images/clean_architecture_reloaded_packages.png)

My second tip is to have a core module which will have these main responsitilities:

-   **Handle global dependency injection.**
-   **Contain extension functions.**
-   **Contain the main framework abstractions.**
-   **Initiate in the main application common 3rd party libraries like Analytics, Crash Reporting, etc.**

My third tip is not at codebase level, but it might be helpful to add code ownership if we are working with feature teams, which is a win in growing organizations where many developers are working on the same codebase.

These are the main benefits of  **Modularization**:

-   **Faster Build Time.**
-   **Package cohesion.**
-   **Re-usability of common functionality.**
-   **Conflicts reduction (especially when working with git flows).**
-   **Feature encapsulation.**
-   **More controlled dependendencies.**
-   **Team work: collaboration between teams.**

I know all this sounds good on paper and although modularizing your android codebase is tricky and challenging (due to all the moving parts involved), the advantages are huge.

## Other Implementation Details

-   [RxJava:](https://github.com/ReactiveX/RxJava)  This one was one of the biggest changes in comparison with the  [previous example.](https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/)  I got rid of RxJava because I do not need it here. By the way, I bumped into many people ONLY using it because of threading. Of course it facilitates our life in that aspect but brings overhead and complexity in other areas. So make sure threading is not the only reason to introduce it in your codebase.
-   Dependency Injection: Simple one using  [Dagger 2,](https://github.com/google/dagger)  and it is out of scope of this article.  [I wrote about it in the past.](https://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/)
-   Unit and integration tests  [are in place.](https://github.com/android10/Android-CleanArchitecture-Kotlin/tree/master/app/src/test/kotlin/com/fernandocejas/sample)
-   Acceptance Tests: Still  [TODO](https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/)  ([PRs](https://github.com/android10/Android-CleanArchitecture-Kotlin/blob/master/app/src/androidTest/kotlin/com/fernandocejas/sample/AcceptanceTest.kt)  are more than welcome).

## Source code and discussions

Source code can be found here:

-   [https://github.com/android10/Android-CleanArchitecture-Kotlin](https://github.com/android10/Android-CleanArchitecture-Kotlin)

For discussions,  [open a new issue on Github,](https://github.com/android10/Android-CleanArchitecture-Kotlin/issues)  so we can continue the conversation  [over there.](https://github.com/android10/Android-CleanArchitecture-Kotlin/issues)

## Conclusion

We have seen the theoretical approach and implementation details. There is much more to explore but that is homework for you :).

Also, it does not matter which architecture you pick for your projects as soon as it fulfills your needs and solves your problems.

**Keep in mind that there are NO silver bullets**  and of course there is always room for improvement, although this should be useful as a starting point.

And some advice:

-   **Do not over think (do not do over engineering).**
-   **Be pragmatic.**
-   **Minimize framework (android) dependencies in your project as much as you can.**
-   **Continuous improvement through refactor.**
-   **Do not write code without tests (I should not be saying this in 2018 :)).**

Something else to add since I have seen discussions around FP vs OOP: Functional Programming is not new and has been there for a long time but nowadays is gaining more and more adopters. And the fact that Kotlin treats functions as first class citizens give us even more power and tools to solve our problems.

Use whatever works for you, here  **I’m conbining what I consider the best of both worlds…**

[So, my dear developer:](https://twitter.com/fernando_cejas/status/989048232805314562)

![clean_architecture](https://fernandocejas.com/assets/images/clean_architecture_reloaded_tweet.png)

## References

-   [Architecting Android…The clean way?](https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/)
-   [Architecting Android…The evolution.](https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/)
-   [Tasting Dagger 2 on Android.](https://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/)
-   [Clean Architecture: Dynamic Parameters in Use Cases.](https://fernandocejas.com/2016/12/24/clean-architecture-dynamic-parameters-in-use-cases/)
    
-   [App modularization and module lazy loading at Instagram and beyond.](https://instagram-engineering.com/app-modularization-and-module-lazy-loading-at-instagram-and-beyond-46b9daa3fea4)
-   [The MVVM Pattern.](https://msdn.microsoft.com/en-us/library/hh848246.aspx)
-   [Try, Option or Either?.](http://blog.xebia.com/try-option-or-either/)
-   [Kotlin’s Nothing Type.](https://proandroiddev.com/kotlins-nothing-type-946de7d464fb)